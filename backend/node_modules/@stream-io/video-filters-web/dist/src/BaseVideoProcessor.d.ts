import { VideoTrackProcessorHooks } from './types';
import { MediaStreamTrackGenerator } from './FallbackGenerator';
import { MediaStreamTrackProcessor } from './FallbackProcessor';
/**
 * Base class for real-time video filters.
 *
 * It sets up the full pipeline that reads frames from the input track,
 * processes them, and outputs a new track with your effect applied. Subclasses
 * only need to implement `initialize` (run once before processing starts) and
 * `transform` (called for every frame).
 *
 * Everything elseâ€”canvas setup, performance tracking, error handling, and
 * clean shutdown is handled for you. Calling `start()` returns a processed
 * `MediaStreamTrack` ready to use.
 */
export declare abstract class BaseVideoProcessor {
    protected readonly track: MediaStreamVideoTrack;
    protected readonly processor: MediaStreamTrackProcessor<VideoFrame>;
    protected readonly generator: MediaStreamTrackGenerator<VideoFrame>;
    protected readonly hooks: VideoTrackProcessorHooks;
    protected readonly abortController: AbortController;
    protected canvas: OffscreenCanvas;
    private frames;
    private delayTotal;
    private lastStatsTime;
    /**
     * Constructs a new instance.
     */
    protected constructor(track: MediaStreamVideoTrack, hooks?: VideoTrackProcessorHooks);
    start(): Promise<MediaStreamTrack>;
    stop(): void;
    private updateStats;
    protected abstract initialize(): Promise<void>;
    protected abstract transform(frame: VideoFrame): Promise<VideoFrame>;
    protected onFlush(): void;
    protected onStop(): void;
    protected get processorName(): string;
}
